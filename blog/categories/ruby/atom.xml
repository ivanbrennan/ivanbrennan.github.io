<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ruby | detached head]]></title>
  <link href="http://ivanbrennan.github.io/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://ivanbrennan.github.io/"/>
  <updated>2013-10-18T07:24:42-04:00</updated>
  <id>http://ivanbrennan.github.io/</id>
  <author>
    <name><![CDATA[Ivan Brennan]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[modules, classes, pterosaurs]]></title>
    <link href="http://ivanbrennan.github.io/blog/2013/10/17/modules/"/>
    <updated>2013-10-17T12:50:00-04:00</updated>
    <id>http://ivanbrennan.github.io/blog/2013/10/17/modules</id>
    <content type="html"><![CDATA[<p><img class="illustration <a" src="href="http://upload.wikimedia.org/wikipedia/commons/3/38/Homology.jpg">http://upload.wikimedia.org/wikipedia/commons/3/38/Homology.jpg</a>" title="&lsquo;wings&rsquo; &lsquo;Pterosaur, bat, and bird wings&rsquo;" ></p>

<p>Pterosaurs, bats, and birds can/could all fly, but each evolved the ability independent of the others. This is an example of <a href="http://en.wikipedia.org/wiki/Convergent_evolution">convergent evolution</a>, the <em>&ldquo;independent evolution of similar features in species of different lineages&rdquo;</em>. The wings of bats, pterosaurs, and birds, the body-plans of marsupials and mammals, and the eyes of vertebrates and cephalopods are just some examples of this.</p>

<p>In Ruby, classes allow objects to be arranged into a hierarchical lineage, using inheritence to pass features from a parent class to all it&rsquo;s descendants. But we often want to share functionality across unrelated classes. Modules allow us to do just that. Let&rsquo;s consider the case of pterosaurs and bats.</p>

<p>``` ruby
module Flyable
  def fly</p>

<pre><code>puts "A #{self.class} is flying."
</code></pre>

<p>  end
end</p>

<p>class Bat
  include Flyable</p>

<p>  def echolocate</p>

<pre><code>puts "A #{self.class} can see in the dark."
</code></pre>

<p>  end
end</p>

<p>class Pterosaur
  include Flyable
end</p>

<p>bert = Bat.new
bert.fly</p>

<h1>=> &ldquo;A Bat is flying.&rdquo;</h1>

<p>phil = Pterosaur.new
phil.fly</p>

<h1>=> &ldquo;A Pterosaur is flying.&rdquo;</h1>

<p>```</p>

<p>Contrast this with sharing functionality via classes. Let&rsquo;s create a couple species of bat by defining descendants of the Bat class:</p>

<p>``` ruby
class SeminoleBat &lt; Bat
  def migrate</p>

<pre><code>puts "A #{self.class} is migrating."
</code></pre>

<p>  end
end</p>

<p>class CanyonBat &lt; Bat
  def hibernate</p>

<pre><code>puts "A #{self.class} hibernating."
</code></pre>

<p>  end
end</p>

<p>sam = SeminoleBat.new
sam.fly</p>

<h1>=> &ldquo;A SeminoleBat is flying.&rdquo;</h1>

<p>sam.echolocate</p>

<h1>=> &ldquo;A SeminoleBat can see in the dark.&rdquo;</h1>

<p>candice = CanyonBat.new
candice.fly</p>

<h1>=> &ldquo;A CanyonBat is flying.&rdquo;</h1>

<p>candice.echolocate</p>

<h1>=> &ldquo;A CanyonBat can see in the dark.&rdquo;</h1>

<p>```</p>

<p>Both <code>sam</code> and <code>candice</code> can echolocate and fly, since the <code>SeminoleBat</code> and <code>CanyonBat</code> classes are descendants of the <code>Bat</code> class. The <code>SeminoleBat</code> and <code>CanyonBat</code> classes also each have unique functionality that distinguishes them, and is not shared between their two classes. Only instances of <code>SeminoleBat</code> can migrate, and only those of <code>CanyonBat</code> can hibernate.</p>

<p>``` ruby
sam.migrate</p>

<h1>=> &ldquo;A SeminoleBat is migrating.&rdquo;</h1>

<p>sam.hibernate</p>

<h1>=> NoMethodError: undefined method `hibernate' for #&lt;SeminoleBat:0x007f88fe006228></h1>

<p>candice.hibernate</p>

<h1>=> &ldquo;A CanyonBat is hibernating.&rdquo;</h1>

<p>candice.migrate</p>

<h1>=> NoMethodError: undefined method `migrate' for #&lt;CanyonBat:0x007f88fe807c38></h1>

<p>```</p>

<p>And while <code>Pterosaur</code>, like <code>Bat</code> and all its descendants, can fly, it can&rsquo;t echolocate, migrate, or hibernate.</p>

<p>``` ruby
phil.echolocate</p>

<h1>=> NoMethodError: undefined method `echolocate' for #&lt;Pterosaur:0x007fdcbc082eb0></h1>

<p>phil.migrate</p>

<h1>=> NoMethodError: undefined method `migrate' for #&lt;Pterosaur:0x007fdcbc082eb0></h1>

<p>phil.hibernate</p>

<h1>=> NoMethodError: undefined method `hibernate' for #&lt;Pterosaur:0x007fdcbc082eb0></h1>

<p>```</p>

<p>There is a bit more to Modules (they can be used to define class methods as well as instance methods, and they can include constants), but the general purpose they serve is to enable sharing functionality across unrelated classes.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[enumerables]]></title>
    <link href="http://ivanbrennan.github.io/blog/2013/10/08/enumerables/"/>
    <updated>2013-10-08T08:38:00-04:00</updated>
    <id>http://ivanbrennan.github.io/blog/2013/10/08/enumerables</id>
    <content type="html"><![CDATA[<p>Ruby provides lots of built-in methods for working with arrays, but at first glance, some seem to be missing from the <a href="http://ruby-doc.org/core-2.0.0/Array.html">Array documentation</a>. A good example is the <code>#find</code> method, which returns the first element satisfying the criteria you provide in a block.
<code>ruby
[1,2,3,4,5].find { |x| x &gt; 2 }  # =&gt; 3
</code>
The fact is, these methods are mixed in from the <a href="http://ruby-doc.org/core-2.0.0/Enumerable.html">Enumerable module</a>, a collection of useful methods that can be applied to Arrays, Ranges, and Sets, among other Ruby classes. A simple check <code>whatever_object.is_a? Enumerable</code> will confirm whether whatever object your dealing with includes the Enumerable module.</p>

<p>One of these methods, <code>#zip</code>, has been calling out to me since I started learning Ruby. It seemed like an alchemical process that merged arrays in a mysterious way. In practice, it simply merges the corresponding elements of each array, returning an array of arrays.
``` ruby
i_got   = [&ldquo;I got the style&rdquo;,</p>

<pre><code>       "I got the clothes",
       "I got the bread",
       "I got the winda"]
</code></pre>

<p>but_not = [&ldquo;but not the grace&rdquo;,</p>

<pre><code>       "but not the face",
       "but not the butter",
       "but not the shutter"]
</code></pre>

<p>i_got.zip(but_not)</p>

<h1>=> [[&ldquo;I got the style&rdquo;, &ldquo;but not the grace&rdquo;],</h1>

<h1>[&ldquo;I got the clothes&rdquo;, &ldquo;but not the face&rdquo;],</h1>

<h1>[&ldquo;I got the bread&rdquo;, &ldquo;but not the butter&rdquo;],</h1>

<h1>[&ldquo;I got the winda&rdquo;, &ldquo;but not the shutter&rdquo;]]</h1>

<p><code>
Pretty nice, but why don't we do [Tom Waits](http://www.youtube.com/watch?v=ByomIJf5n9w) proud and join those phrases?
</code> ruby
i_got.zip(but_not) {|got_not| got_not.join(&ldquo;, &rdquo;)}</p>

<h1>=> nil</h1>

<p><code>
Whoops! Passing `#zip` a block will invoke the block for each output array, but return `nil` at the end of the day. A call `#map` to will do the trick.
</code> ruby
i_got.zip(but_not).map {|got_not| got_not.join(&ldquo;, &rdquo;)}</p>

<h1>=> [&ldquo;I got the style, but not the grace&rdquo;,</h1>

<h1>&ldquo;I got the clothes, but not the face&rdquo;,</h1>

<h1>&ldquo;I got the bread, but not the butter&rdquo;,</h1>

<h1>&ldquo;I got the winda, but not the shutter&rdquo;]</h1>

<p><code>
In fact, `#zip` can merge any number of arrays...
</code> ruby
bagels  = [&ldquo;sesame bagel&rdquo;,</p>

<pre><code>       "plain bagel",
       "poppy bagel",
       "pumpernickel bagel"]
</code></pre>

<p>spreads = [&ldquo;cream cheese&rdquo;,</p>

<pre><code>       "butter",
       "peanut-butter",
       "jam"]
</code></pre>

<p>extras  = [&ldquo;lox&rdquo;,</p>

<pre><code>       "tomato",
       "chives",
       "lettuce"]
</code></pre>

<p>bagels.zip(spreads, extras).map do |bgl, spd, xtr|
  &ldquo;#{bgl} with #{spd} and #{xtr}&rdquo;
end</p>

<h1>=> [&ldquo;sesame bagel with cream cheese and lox&rdquo;,</h1>

<h1>&ldquo;plain bagel with butter and tomato&rdquo;,</h1>

<h1>&ldquo;poppy bagel with peanut-butter and chives&rdquo;,</h1>

<h1>&ldquo;pumpernickel bagel with jam and lettuce&rdquo;]</h1>

<p><code>``
Not all the tastiest combinations, but that's how</code>#zip` works, it just matches up the elements in whatever order they appeared in the original arrays.</p>
]]></content>
  </entry>
  
</feed>
