<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ruby | codemachine]]></title>
  <link href="http://ivanbrennan.github.io/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://ivanbrennan.github.io/"/>
  <updated>2016-12-20T20:19:51-05:00</updated>
  <id>http://ivanbrennan.github.io/</id>
  <author>
    <name><![CDATA[Ivan Brennan]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Faster Specs]]></title>
    <link href="http://ivanbrennan.github.io/blog/2014/10/27/faster-specs/"/>
    <updated>2014-10-27T22:23:00-04:00</updated>
    <id>http://ivanbrennan.github.io/blog/2014/10/27/faster-specs</id>
    <content type="html"><![CDATA[<p>Getting the full benefits of <a href="http://en.wikipedia.org/wiki/Test-driven_development">TDD</a> requires fast-running specs. The feedback cycle is what makes the difference between a pleasurable &ldquo;red-green-refactor&rdquo; flow and an eternity of testing-tedium where the only reason you&rsquo;re <em>writing</em> tests is so you be <em>done</em> writing them. While TDD is lauded in the Rails community, many large Rails apps suffer from slow-running test suites.</p>

<p>I&rsquo;ve been working with a Rails app that has a couple of bloated, callback-ridden models. Much of the test-suite uses FactoryGirl, and generating test objects for those big models and their associations can slow things down to a crawl. So when a new feature came along, I took the opportunity to write some fast unit-tests in a different style.</p>

<h3>Couch-Surfer</h3>

<p>Imagine an app that logs the journeys of world-travellers (lots of them) as they couch-surf around the globe visiting homebody friends. Each traveller periodically sends a postcard to their next host to let them know how far off they are. We have a few persisted models: Traveller, Homebody, CouchCrash, and Postcard.</p>

<p>The Traveller and Homebody models are rather large, so I&rsquo;ve abbreviated them here:</p>

<p>``` ruby
class Traveller &lt; ActiveRecord::Base
  has_many :couch_crashes
  has_many :homebodies, through: :couch_crashes
  # and many more associations, validations, callbacks&hellip;
end</p>

<p>class Homebody &lt; ActiveRecord::Base
  has_many :couch_crashes
  # and many more associations, validations, callbacks&hellip;
end
```</p>

<p>CouchCrash and Postcard are pretty small, despite their associations with the larger models:
``` ruby
class CouchCrash &lt; ActiveRecord::Base
  belongs_to :traveller
  belongs_to :homebody
  has_many :postcards</p>

<p>  validates_presence_of :traveller, :homebody, :arrival_date
end</p>

<p>class Postcard &lt; ActiveRecord::Base
  belongs_to :traveller
  belongs_to :couch_crash
  belongs_to :homebody, through: :couch_crash</p>

<p>  validates_presence_of :traveller, :couch_crash, :distance
end
```</p>

<p>Each visit, or <code>couch_crash</code>, is scheduled with an <code>arrival_date</code>. But these aren&rsquo;t always accurate, as it&rsquo;s hard to know exactly when the traveller will reach their destination. We&rsquo;d like to add a feature that assesses the status of a visit as &ldquo;far off&rdquo;, &ldquo;approaching&rdquo;, or &ldquo;in progress&rdquo; based on the arrival date and available postcards. We won&rsquo;t bother with a &ldquo;completed&rdquo; status since couch-crashers have been known to stick around forever.</p>

<p>For simplicity&rsquo;s sake, we&rsquo;ll say any visit whose arrival date is more than a week away is &ldquo;far off&rdquo;. Within a week of the arrival date, an &ldquo;approaching&rdquo; status requires a postcard from within 100 miles and &ldquo;in Progress&rdquo; requires one within 5 miles (I know, that&rsquo;s a waste of a stamp). Otherwise, with either no postcards or only those over 100 miles away, the visit remains &ldquo;far off&rdquo;.</p>

<h3>Approaching the spec</h3>

<p>A spec for the &ldquo;approaching&rdquo; status using FactoryGirl might look like this:</p>

<p>```ruby
describe CouchCrash do
  describe &lsquo;#status&rsquo; do</p>

<pre><code>context 'within 1 week of arrival date' do
  context 'with a postcard from 100 miles away' do

    it 'is "approaching"' do
      visit = FactoryGirl.build(:couch_crash, arrival_date: 1.week.from_now)
      postcard_100 = FactoryGirl.build(:postcard, distance: 100)

      visit.stub(:postcards).and_return([postcard_100])

      expect(visit.status).to eq(:approaching)
    end

  end
end
</code></pre>

<p>  end
end
```</p>

<p>Using <code>build</code> rather than <code>create</code> should keep us from hitting the database. Stubbing the association between <code>visit</code> and its postcards should do the same. On the surface, this looks like a well-isolated, fast unit-test, but let&rsquo;s take a closer look at the factories we&rsquo;re using:</p>

<p>```ruby</p>

<h1>spec/factories/couch_crashes.rb</h1>

<p>FactoryGirl.define do
  factory :couch_crash do</p>

<pre><code>traveller
homebody
arrival_date 2.weeks.from_now
</code></pre>

<p>  end
end</p>

<h1>spec/factories/post_cards.rb</h1>

<p>FactoryGirl.define do
  factory :post_card do</p>

<pre><code>traveller
couch_crash
distance 300
</code></pre>

<p>  end
end
```</p>

<p>It&rsquo;s best practice to define your factories with the minimum set of attributes necessary for a valid object. You don&rsquo;t want to set land-mines for the next developer that comes along and calls <code>create</code>. So the couch_crashes factory generates associated traveller and homebody objects. In doing so, it involves two of our most bloated models. Take a look at their factories:</p>

<p>```ruby</p>

<h1>spec/factories/travellers.rb</h1>

<p>FactoryGirl.define do
  factory :traveller do</p>

<pre><code>first_name "Yngwie"
last_name  "Malmsteen"
association :hometown, factory: :city
luggage
bicycle

after(:build) do |traveller|
  pump = FactoryGirl.build(:bicycle_pump)
  traveller.bike_pump = pump
  traveller.inflate_tires
  traveller.pack_luggage
  traveller.buy_stamps
  # etc.
</code></pre>

<p>  end
end</p>

<h1>spec/factories/homebodies.rb</h1>

<p>FactoryGirl.define do
  factory :homebody do</p>

<pre><code>first_name "Joe"
last_name  "Stumps"
spouse
credit_score 400
house
couch
car
dog
# etc.
</code></pre>

<p>  end
end
```</p>

<p>We&rsquo;re also unintentionally hitting the database, as FactoryGirl saves both traveller and homebody in order to build the association. You can avoid this by specifying a build-strategy for the association:</p>

<p><code>ruby
factory :couch_crash do
  association :traveller, strategy: :build
  association :homebody,  strategy: :build
  ...
</code></p>

<p>You&rsquo;d also have to change the syntax in the associated factories:
```ruby
factory :traveller do
  &hellip;
  association :luggage, strategy: :build
  association :bicycle, strategy: :build
  &hellip;
end</p>

<p>factory :homebody do
  &hellip;
  association :house, strategy: :build
  association :couch, strategy: :build
  association :car,   strategy: :build
  association :dog,   strategy: :build
  &hellip;
end
```</p>

<p>It would be nice to avoid involving these large models any more than necessary, so let&rsquo;s rewrite the spec with a different technique. Instead of using factories to generate complex test objects, we&rsquo;ll use test doubles to stub out the context.</p>

<h3>Test-doubles</h3>

<p>Rspec&rsquo;s <code>double</code> method returns a test-double &mdash; a dummy object that stands in for a more complex object from your production code. The double can be told how to respond to various method calls:
```ruby
red_thing = double(&ldquo;thing&rdquo;)</p>

<h1>The argument (ie. &ldquo;thing&rdquo;) is optional.</h1>

<h1>It provides a name that test output can make use of.</h1>

<p>red_thing.stub(:color).and_return(&ldquo;red&rdquo;)</p>

<h1>equivalent form:</h1>

<p>red_thing.stub(:color) { &ldquo;red&rdquo; }</p>

<h1>Or, more concisely:</h1>

<p>red_house = double(&ldquo;thing&rdquo;, color: &ldquo;red&rdquo;)
```</p>

<p>The double only knows what it&rsquo;s been told explicitly, and will raise an error upon receiving any unexpected method call. If you&rsquo;re using Rspec 3, you can also use &ldquo;<a href="https://www.relishapp.com/rspec/rspec-mocks/v/3-1/docs/verifying-doubles">verifying doubles</a>&rdquo;, which know what class of object they&rsquo;re standing in for and will ensure that any methods being stubbed are actually present in the code.</p>

<h3>Rewrite</h3>

<p>While our spec should still read from the ground up, beginning with the context and arriving at an expectation, it can be helpful when <em>writing</em> to start with the expectation and work backwards. This is especially true when the context is complex. It also helps clarify what needs to be stubbed out, so let&rsquo;s give it a shot.
<code>ruby
expect(visit.status).to eq(:approaching)
</code>
What is <code>visit</code>? Just a test double with the right attributes:
<code>ruby
visit = double("visit", arrival_date: 1.week.from_now, postcards: [postcard_100])
</code>
What about <code>postcard_100</code>? Just another test double.
<code>ruby
postcard_100 = double("postcard", distance: 100)
</code>
Putting it all together, we have:</p>

<p>```ruby
context &lsquo;within 1 week of arrival date&rsquo; do
  context &lsquo;with a postcard from 100 miles away&rsquo; do</p>

<pre><code>it 'is "approaching"' do
  postcard_100 = double("postcard", distance: 100)
  visit = double("visit", arrival_date: 1.week.from_now, postcards: [postcard_100])

  expect(visit.status).to eq(:approaching)
end
</code></pre>

<p>  end
end
```</p>

<p>I initially wanted faster specs to enable a better TDD flow. A nice side benefit of writing these stubbed tests is that it illuminates the dependencies and coupling in the production code you&rsquo;re working with and encourages better composition overall. FactoryGirl is still a wonderful tool, but it shouldn&rsquo;t be the only one in your belt.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[yield the weird]]></title>
    <link href="http://ivanbrennan.github.io/blog/2013/10/23/yield-the-weird/"/>
    <updated>2013-10-23T22:32:00-04:00</updated>
    <id>http://ivanbrennan.github.io/blog/2013/10/23/yield-the-weird</id>
    <content type="html"><![CDATA[<p>I&rsquo;m messing around with <code>yield</code> to get a handle on the various closures in Ruby, and I built a method that returns a rotated-mapped array. You could of course do this with the built-in <code>#rotate</code> and <code>#map</code> methods, but what fun is that?
```ruby
def rotomap(arr, n)
  arr.each_index.inject([]) do |roto, i|</p>

<pre><code>roto &lt;&lt; yield( arr[ (i+n) % (arr.count) ] )
</code></pre>

<p>  end
end</p>

<p>rotomap([1,2,3,4,5], 3) { |x| &ldquo;#{x * 5} merge requests&rdquo; }</p>

<h1>=> [&ldquo;20 merge requests&rdquo;, &ldquo;25 merge requests&rdquo;, &ldquo;5 merge requests&rdquo;, &ldquo;10 merge requests&rdquo;, &ldquo;15 merge requests&rdquo;]</h1>

<p>```
I don&rsquo;t imagine there&rsquo;s a lot of rotomapping going on out there, but it was fun to slap this together.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[modules, classes, pterosaurs]]></title>
    <link href="http://ivanbrennan.github.io/blog/2013/10/17/modules/"/>
    <updated>2013-10-17T12:50:00-04:00</updated>
    <id>http://ivanbrennan.github.io/blog/2013/10/17/modules</id>
    <content type="html"><![CDATA[<p><img class="illustration <a" src="href="http://upload.wikimedia.org/wikipedia/commons/3/38/Homology.jpg">http://upload.wikimedia.org/wikipedia/commons/3/38/Homology.jpg</a>" title="&lsquo;wings&rsquo; &lsquo;Pterosaur, bat, and bird wings&rsquo;" ></p>

<p>Pterosaurs, bats, and birds can/could all fly, but each evolved the ability independent of the others. This is an example of <a href="http://en.wikipedia.org/wiki/Convergent_evolution">convergent evolution</a>, the <em>&ldquo;independent evolution of similar features in species of different lineages&rdquo;</em>. The wings of bats, pterosaurs, and birds, the body-plans of marsupials and mammals, and the eyes of vertebrates and cephalopods are just some examples of this.</p>

<p>In Ruby, classes allow objects to be arranged into a hierarchical lineage, using inheritence to pass features from a parent class to all it&rsquo;s descendants. But we often want to share functionality across unrelated classes. Modules allow us to do just that. Let&rsquo;s consider the case of pterosaurs and bats.</p>

<p>``` ruby
module Flyable
  def fly</p>

<pre><code>puts "A #{self.class} is flying."
</code></pre>

<p>  end
end</p>

<p>class Bat
  include Flyable</p>

<p>  def echolocate</p>

<pre><code>puts "A #{self.class} can see in the dark."
</code></pre>

<p>  end
end</p>

<p>class Pterosaur
  include Flyable
end</p>

<p>bert = Bat.new
bert.fly</p>

<h1>=> &ldquo;A Bat is flying.&rdquo;</h1>

<p>phil = Pterosaur.new
phil.fly</p>

<h1>=> &ldquo;A Pterosaur is flying.&rdquo;</h1>

<p>```</p>

<p>Contrast this with sharing functionality via classes. Let&rsquo;s create a couple species of bat by defining descendants of the Bat class:</p>

<p>``` ruby
class SeminoleBat &lt; Bat
  def migrate</p>

<pre><code>puts "A #{self.class} is migrating."
</code></pre>

<p>  end
end</p>

<p>class CanyonBat &lt; Bat
  def hibernate</p>

<pre><code>puts "A #{self.class} hibernating."
</code></pre>

<p>  end
end</p>

<p>sam = SeminoleBat.new
sam.fly</p>

<h1>=> &ldquo;A SeminoleBat is flying.&rdquo;</h1>

<p>sam.echolocate</p>

<h1>=> &ldquo;A SeminoleBat can see in the dark.&rdquo;</h1>

<p>candice = CanyonBat.new
candice.fly</p>

<h1>=> &ldquo;A CanyonBat is flying.&rdquo;</h1>

<p>candice.echolocate</p>

<h1>=> &ldquo;A CanyonBat can see in the dark.&rdquo;</h1>

<p>```</p>

<p>Both <code>sam</code> and <code>candice</code> can echolocate and fly, since the <code>SeminoleBat</code> and <code>CanyonBat</code> classes are descendants of the <code>Bat</code> class. The <code>SeminoleBat</code> and <code>CanyonBat</code> classes also each have unique functionality that distinguishes them, and is not shared between their two classes. Only instances of <code>SeminoleBat</code> can migrate, and only those of <code>CanyonBat</code> can hibernate.</p>

<p>``` ruby
sam.migrate</p>

<h1>=> &ldquo;A SeminoleBat is migrating.&rdquo;</h1>

<p>sam.hibernate</p>

<h1>=> NoMethodError: undefined method `hibernate' for #&lt;SeminoleBat:0x007f88fe006228></h1>

<p>candice.hibernate</p>

<h1>=> &ldquo;A CanyonBat is hibernating.&rdquo;</h1>

<p>candice.migrate</p>

<h1>=> NoMethodError: undefined method `migrate' for #&lt;CanyonBat:0x007f88fe807c38></h1>

<p>```</p>

<p>And while <code>Pterosaur</code>, like <code>Bat</code> and all its descendants, can fly, it can&rsquo;t echolocate, migrate, or hibernate.</p>

<p>``` ruby
phil.echolocate</p>

<h1>=> NoMethodError: undefined method `echolocate' for #&lt;Pterosaur:0x007fdcbc082eb0></h1>

<p>phil.migrate</p>

<h1>=> NoMethodError: undefined method `migrate' for #&lt;Pterosaur:0x007fdcbc082eb0></h1>

<p>phil.hibernate</p>

<h1>=> NoMethodError: undefined method `hibernate' for #&lt;Pterosaur:0x007fdcbc082eb0></h1>

<p>```</p>

<p>There is a bit more to Modules (they can be used to define class methods as well as instance methods, and they can include constants), but the general purpose they serve is to enable sharing functionality across unrelated classes.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[enumerables]]></title>
    <link href="http://ivanbrennan.github.io/blog/2013/10/08/enumerables/"/>
    <updated>2013-10-08T08:38:00-04:00</updated>
    <id>http://ivanbrennan.github.io/blog/2013/10/08/enumerables</id>
    <content type="html"><![CDATA[<p>Ruby provides lots of built-in methods for working with arrays, but at first glance, some seem to be missing from the <a href="http://ruby-doc.org/core-2.0.0/Array.html">Array documentation</a>. A good example is the <code>#find</code> method, which returns the first element satisfying the criteria you provide in a block.
<code>ruby
[1,2,3,4,5].find { |x| x &gt; 2 }  # =&gt; 3
</code>
The fact is, these methods are mixed in from the <a href="http://ruby-doc.org/core-2.0.0/Enumerable.html">Enumerable module</a>, a collection of useful methods that can be applied to Arrays, Ranges, and Sets, among other Ruby classes. A simple check <code>whatever_object.is_a? Enumerable</code> will confirm whether whatever object your dealing with includes the Enumerable module.</p>

<p>One of these methods, <code>#zip</code>, has been calling out to me since I started learning Ruby. It seemed like an alchemical process that merged arrays in a mysterious way. In practice, it simply merges the corresponding elements of each array, returning an array of arrays.
``` ruby
i_got   = [&ldquo;I got the style&rdquo;,</p>

<pre><code>       "I got the clothes",
       "I got the bread",
       "I got the winda"]
</code></pre>

<p>but_not = [&ldquo;but not the grace&rdquo;,</p>

<pre><code>       "but not the face",
       "but not the butter",
       "but not the shutter"]
</code></pre>

<p>i_got.zip(but_not)</p>

<h1>=> [[&ldquo;I got the style&rdquo;, &ldquo;but not the grace&rdquo;],</h1>

<h1>[&ldquo;I got the clothes&rdquo;, &ldquo;but not the face&rdquo;],</h1>

<h1>[&ldquo;I got the bread&rdquo;, &ldquo;but not the butter&rdquo;],</h1>

<h1>[&ldquo;I got the winda&rdquo;, &ldquo;but not the shutter&rdquo;]]</h1>

<p><code>
Pretty nice, but why don't we do [Tom Waits](http://www.youtube.com/watch?v=ByomIJf5n9w) proud and join those phrases?
</code> ruby
i_got.zip(but_not) {|got_not| got_not.join(&ldquo;, &rdquo;)}</p>

<h1>=> nil</h1>

<p><code>
Whoops! Passing `#zip` a block will invoke the block for each output array, but return `nil` at the end of the day. A call to `#map` to will do the trick.
</code> ruby
i_got.zip(but_not).map {|got_not| got_not.join(&ldquo;, &rdquo;)}</p>

<h1>=> [&ldquo;I got the style, but not the grace&rdquo;,</h1>

<h1>&ldquo;I got the clothes, but not the face&rdquo;,</h1>

<h1>&ldquo;I got the bread, but not the butter&rdquo;,</h1>

<h1>&ldquo;I got the winda, but not the shutter&rdquo;]</h1>

<p><code>
In fact, `#zip` can merge any number of arrays...
</code> ruby
bagels  = [&ldquo;sesame bagel&rdquo;,</p>

<pre><code>       "plain bagel",
       "poppy bagel",
       "pumpernickel bagel"]
</code></pre>

<p>spreads = [&ldquo;cream cheese&rdquo;,</p>

<pre><code>       "butter",
       "peanut-butter",
       "jam"]
</code></pre>

<p>extras  = [&ldquo;lox&rdquo;,</p>

<pre><code>       "tomato",
       "chives",
       "lettuce"]
</code></pre>

<p>bagels.zip(spreads, extras).map do |bgl, spd, xtr|
  &ldquo;#{bgl} with #{spd} and #{xtr}&rdquo;
end</p>

<h1>=> [&ldquo;sesame bagel with cream cheese and lox&rdquo;,</h1>

<h1>&ldquo;plain bagel with butter and tomato&rdquo;,</h1>

<h1>&ldquo;poppy bagel with peanut-butter and chives&rdquo;,</h1>

<h1>&ldquo;pumpernickel bagel with jam and lettuce&rdquo;]</h1>

<p><code>``
Not all the tastiest combinations, but that's how</code>#zip` works, it just matches up the elements in whatever order they appeared in the original arrays.</p>
]]></content>
  </entry>
  
</feed>
