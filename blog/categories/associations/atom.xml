<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: associations | codemachine]]></title>
  <link href="http://ivanbrennan.github.io/blog/categories/associations/atom.xml" rel="self"/>
  <link href="http://ivanbrennan.github.io/"/>
  <updated>2016-12-20T23:33:17-05:00</updated>
  <id>http://ivanbrennan.github.io/</id>
  <author>
    <name><![CDATA[Ivan Brennan]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Polymorphic Mythology]]></title>
    <link href="http://ivanbrennan.github.io/blog/2014/01/14/polymorphic-mythology/"/>
    <updated>2014-01-14T17:33:00-05:00</updated>
    <id>http://ivanbrennan.github.io/blog/2014/01/14/polymorphic-mythology</id>
    <content type="html"><![CDATA[<p>I was recently introduced to polymorphic associations in Active Record. They provide some extra flexibility in how you choose to wire up your models, and can be an elegant solution to some otherwise awkward problems. To demonstrate, I&rsquo;ll show how you could use them to catalog a collection of mythology.</p>

<p>We&rsquo;ll start with a tiny collection of tales: The Reign of the Hydra, The Golden Voyage, and The Life of King Adrastus. In addition to needing a myth model, we&rsquo;ll need models for beasts, voyages, and heros. Let&rsquo;s set things up so that a character/event/etc. can be the central figure in any number of myths, with each myth centered around a single such figure. Our beast model, then, could simply be,</p>

<p><code>ruby
class Beast &lt; ActiveRecord::Base
  has_many :myths
end
</code></p>

<p>backed by a straightforward migration,</p>

<p>```ruby
class CreateBeasts &lt; ActiveRecord::Migration
  def change</p>

<pre><code>create_table :beasts do |t|
  t.string :name
end
</code></pre>

<p>  end
end
```</p>

<p>But wiring up the myth model isn&rsquo;t so simple. We could write three <code>belongs_to</code> statements into <code>myth.rb</code>, create three columns &mdash; beast_id, voyage_id, and hero_id &mdash; in the myths table, and find a way to enforce that two of the three always hold null values, but that&rsquo;s pretty cumbersome. Plus, as our catalog expands and we discover new types of central-figures (fools, floods, fires), we&rsquo;ll have to add more columns to accommodate any new classes we create. That&rsquo;s a lot of work to store a whole lot of nils.</p>

<p>Polymorphic associations allow you to handle this more elegantly. Let&rsquo;s describe the role that our central-figure plays in the context of a myth. For lack of a better term, I&rsquo;ll call it &ldquo;memorable&rdquo;. A dragon ravishing the countryside, an epic voyage, a tragic hero, these are all &ldquo;memorable&rdquo; things that could take center-stage in a myth. Using this common thread, we&rsquo;ll build a polymorphic association that can relate a myth to any such &ldquo;memorable&rdquo; object.</p>

<p><code>ruby
class Myth &lt; ActiveRecord::Base
  belongs_to :memorable, :polymorphic =&gt; true
end
</code></p>

<p>At the other end of the association, we&rsquo;ll tweak the <code>has_many</code> statements in each of our &ldquo;memorable&rdquo; models, declaring the role they can play in relation to a myth. The beast model, for example, becomes</p>

<p><code>ruby
class Beast &lt; ActiveRecord::Base
  has_many :myths, :as =&gt; :memorable
end
</code></p>

<p>Now we can back the myth model with a much simpler table. The &ldquo;memorable&rdquo; central-figure&rsquo;s id and its type will be stored in a pair of columns, providing a myth with all it needs (a foreign key and the table that key applies to) to retrieve its central-figure.</p>

<p>```ruby
class CreateMyths &lt; ActiveRecord::Migration
  def change</p>

<pre><code>create_table :myths do |t|
  t.string  :name

  t.integer :memorable_id
  t.string  :memorable_type
end
</code></pre>

<p>  end
end
```</p>

<p>Active Record provides a shorthand for creating such a pair of columns: <code>t.references :memorable, :polymorphic =&gt; true</code>, which we could use in place of lines 6 and 7 above.</p>

<p>The polymorphic association allows us to create associations between existing objects,</p>

<p>```ruby
adrastus = Hero.create(:name => &ldquo;Adrastus&rdquo;)
life = Myth.create(:name => &ldquo;The Life of King Adrastus&rdquo;)
life.memorable = adrastus</p>

<p>afterlife = Myth.create(:name => &ldquo;The Afterlife of King Adrastus&rdquo;)
adrastus.myths &lt;&lt; afterlife
```</p>

<p>and to build associated myths off of a given &ldquo;memorable&rdquo; object,</p>

<p>```ruby
adrastus.myths.build(:name => &ldquo;Adrastus &ndash; The Prequel&rdquo;)
adrastus.save</p>

<p>adrastus.myths.create(:name => &ldquo;Adrastus IV &ndash; The Return&rdquo;)
```</p>

<p>Note, however, that we can&rsquo;t build a &ldquo;memorable&rdquo; object off of a given myth, since the type of object (hero, voyage, etc.) is ambiguous.</p>
]]></content>
  </entry>
  
</feed>
