<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: unix | detached head]]></title>
  <link href="http://ivanbrennan.github.io/blog/categories/unix/atom.xml" rel="self"/>
  <link href="http://ivanbrennan.github.io/"/>
  <updated>2014-11-06T23:30:30-05:00</updated>
  <id>http://ivanbrennan.github.io/</id>
  <author>
    <name><![CDATA[Ivan Brennan]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[search &amp; replace]]></title>
    <link href="http://ivanbrennan.github.io/blog/2014/11/04/search-and-replace/"/>
    <updated>2014-11-04T08:05:00-05:00</updated>
    <id>http://ivanbrennan.github.io/blog/2014/11/04/search-and-replace</id>
    <content type="html"><![CDATA[<p>Performing a project-wide search-and-replace is a common task, and yet I still forget how to do it in Vim. While there&rsquo;s not that much to it (build an argument list of relevant files and run a global substitution across them), I&rsquo;ve had to look it up enough times to start wondering if there&rsquo;s a better way. I ended up writing a shell function, as well as a Ruby-specific wrapper for it.</p>

<p>Now if I want to rename a function across my project&rsquo;s javascript files, I can drop onto the command-line and run:
<code>
greplace **.js uglyFunctionName nicerFunctionName
</code>
Or, if I&rsquo;m renaming a Ruby method:
<code>
rupl bad_method_name good_method_name
</code></p>

<h2>The Sauce</h2>

<p>Using <code>find</code>, <code>grep</code>, and <code>sed</code> in concert, we declare which files to search, what to search for, and what to do with those files that contain a match.
```bash
greplace() {
  if [ &ldquo;$#&rdquo; != 3 ]; then</p>

<pre><code>echo "Usage: greplace file_pattern search_pattern replacement"
return 1
</code></pre>

<p>  else</p>

<pre><code>file_pattern=$1
search_pattern=$2
replacement=$3

# This is built for BSD grep and the sed bundled with OS X.
# GNU grep takes -Z instead of --null, and other versions of sed may not support the -i '' syntax.

find . -name "$file_pattern" -exec grep -lw --null "$search_pattern" {} + |
xargs -0 sed -i '' "s/[[:&lt;:]]$search_pattern[[:&gt;:]]/$replacement/g"
</code></pre>

<p>  fi
}</p>

<p>rupl() {
  if [ &ldquo;$#&rdquo; != 2 ]; then</p>

<pre><code>echo "Usage: rupl search_pattern replacement"
return 1
</code></pre>

<p>  else</p>

<pre><code>search_pattern=$1
replacement=$2

greplace '**.rb' "$search_pattern" "$replacement"
</code></pre>

<p>  fi
}
```</p>

<h2>Ingredients</h2>

<p>The first thing <code>greplace</code> does is test whether it received the wrong number of arguments: <code>[ "$#" != 3 ]</code>. If so, it prints a usage message and returns an error code. Otherwise, it sets some local variables with more memorable names than <code>1</code>, <code>2</code>, and <code>3</code>.</p>

<p>Next, we <code>find</code> pathnames in the current directory (and subdirectories) that match <code>file_pattern</code>. Using <code>find ... --exec &lt;command&gt; {};</code> runs a command on each found path, expanding <code>{}</code> to the pathname. Replacing <code>;</code> with <code>+</code> will instead expand <code>{}</code> to as many of the found pathnames as possible. This allows us to feed all the found files as arguments to a single <code>grep</code>.</p>

<p>We <code>grep</code> the relevant files for <code>search_pattern</code>, restricting results to the names of files (<code>-l</code>) that contain a whole-word (<code>-w</code>) match. We also print a <a href="http://en.wikipedia.org/wiki/Null_character">null-character</a> after each filename in the results (<code>--null</code>), which will be useful as a delimiter in the next step.</p>

<p>The results of <code>grep</code> are piped into <code>xargs -0</code>, which constructs an argument list (recognizing the null-character delimiter) and feeds this list to <code>sed</code> for further processing.</p>

<p>We then use <code>sed -i</code> to edit each file &ldquo;in place&rdquo; (rather than writing results to stdout) without creating any backup files (<code>''</code>), which could be risky, but since I&rsquo;m working with Git this seems reasonable.</p>

<p>The actual search-and-replace is simply a pattern substitution. The <code>[[:&lt;:]]</code> and <code>[[:&gt;:]]</code> delimiters restrict it to whole-word matches.</p>

<h2>Caveats</h2>

<p>A few things limit this function&rsquo;s portability. For one, not all versions of <code>grep</code> recognize <code>--null</code>. GNU grep uses <code>-Z</code> instead. Also, the <code>-i ''</code> syntax may not be recognized by all versions of <code>sed</code> (actually, from what I was able to gather, that syntax might be unique to the version bundled with OSX).</p>

<p>That being said, it would only take a few minor tweaks to get this working on a different system.</p>
]]></content>
  </entry>
  
</feed>
