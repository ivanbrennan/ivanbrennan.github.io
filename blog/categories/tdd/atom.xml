<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: TDD, | codemachine]]></title>
  <link href="http://ivanbrennan.github.io/blog/categories/tdd/atom.xml" rel="self"/>
  <link href="http://ivanbrennan.github.io/"/>
  <updated>2018-01-06T13:51:46-05:00</updated>
  <id>http://ivanbrennan.github.io/</id>
  <author>
    <name><![CDATA[Ivan Brennan]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Faster Specs]]></title>
    <link href="http://ivanbrennan.github.io/blog/2014/10/27/faster-specs/"/>
    <updated>2014-10-27T22:23:00-04:00</updated>
    <id>http://ivanbrennan.github.io/blog/2014/10/27/faster-specs</id>
    <content type="html"><![CDATA[<p>Getting the full benefits of <a href="http://en.wikipedia.org/wiki/Test-driven_development">TDD</a> requires fast-running specs. The feedback cycle is what makes the difference between a pleasurable &ldquo;red-green-refactor&rdquo; flow and an eternity of testing-tedium where the only reason you&rsquo;re <em>writing</em> tests is so you be <em>done</em> writing them. While TDD is lauded in the Rails community, many large Rails apps suffer from slow-running test suites.</p>

<p>I&rsquo;ve been working with a Rails app that has a couple of bloated, callback-ridden models. Much of the test-suite uses FactoryGirl, and generating test objects for those big models and their associations can slow things down to a crawl. So when a new feature came along, I took the opportunity to write some fast unit-tests in a different style.</p>

<h3>Couch-Surfer</h3>

<p>Imagine an app that logs the journeys of world-travellers (lots of them) as they couch-surf around the globe visiting homebody friends. Each traveller periodically sends a postcard to their next host to let them know how far off they are. We have a few persisted models: Traveller, Homebody, CouchCrash, and Postcard.</p>

<p>The Traveller and Homebody models are rather large, so I&rsquo;ve abbreviated them here:</p>

<p>``` ruby
class Traveller &lt; ActiveRecord::Base
  has_many :couch_crashes
  has_many :homebodies, through: :couch_crashes
  # and many more associations, validations, callbacks&hellip;
end</p>

<p>class Homebody &lt; ActiveRecord::Base
  has_many :couch_crashes
  # and many more associations, validations, callbacks&hellip;
end
```</p>

<p>CouchCrash and Postcard are pretty small, despite their associations with the larger models:
``` ruby
class CouchCrash &lt; ActiveRecord::Base
  belongs_to :traveller
  belongs_to :homebody
  has_many :postcards</p>

<p>  validates_presence_of :traveller, :homebody, :arrival_date
end</p>

<p>class Postcard &lt; ActiveRecord::Base
  belongs_to :traveller
  belongs_to :couch_crash
  belongs_to :homebody, through: :couch_crash</p>

<p>  validates_presence_of :traveller, :couch_crash, :distance
end
```</p>

<p>Each visit, or <code>couch_crash</code>, is scheduled with an <code>arrival_date</code>. But these aren&rsquo;t always accurate, as it&rsquo;s hard to know exactly when the traveller will reach their destination. We&rsquo;d like to add a feature that assesses the status of a visit as &ldquo;far off&rdquo;, &ldquo;approaching&rdquo;, or &ldquo;in progress&rdquo; based on the arrival date and available postcards. We won&rsquo;t bother with a &ldquo;completed&rdquo; status since couch-crashers have been known to stick around forever.</p>

<p>For simplicity&rsquo;s sake, we&rsquo;ll say any visit whose arrival date is more than a week away is &ldquo;far off&rdquo;. Within a week of the arrival date, an &ldquo;approaching&rdquo; status requires a postcard from within 100 miles and &ldquo;in Progress&rdquo; requires one within 5 miles (I know, that&rsquo;s a waste of a stamp). Otherwise, with either no postcards or only those over 100 miles away, the visit remains &ldquo;far off&rdquo;.</p>

<h3>Approaching the spec</h3>

<p>A spec for the &ldquo;approaching&rdquo; status using FactoryGirl might look like this:</p>

<p>```ruby
describe CouchCrash do
  describe &lsquo;#status&rsquo; do</p>

<pre><code>context 'within 1 week of arrival date' do
  context 'with a postcard from 100 miles away' do

    it 'is "approaching"' do
      visit = FactoryGirl.build(:couch_crash, arrival_date: 1.week.from_now)
      postcard_100 = FactoryGirl.build(:postcard, distance: 100)

      visit.stub(:postcards).and_return([postcard_100])

      expect(visit.status).to eq(:approaching)
    end

  end
end
</code></pre>

<p>  end
end
```</p>

<p>Using <code>build</code> rather than <code>create</code> should keep us from hitting the database. Stubbing the association between <code>visit</code> and its postcards should do the same. On the surface, this looks like a well-isolated, fast unit-test, but let&rsquo;s take a closer look at the factories we&rsquo;re using:</p>

<p>```ruby</p>

<h1>spec/factories/couch_crashes.rb</h1>

<p>FactoryGirl.define do
  factory :couch_crash do</p>

<pre><code>traveller
homebody
arrival_date 2.weeks.from_now
</code></pre>

<p>  end
end</p>

<h1>spec/factories/post_cards.rb</h1>

<p>FactoryGirl.define do
  factory :post_card do</p>

<pre><code>traveller
couch_crash
distance 300
</code></pre>

<p>  end
end
```</p>

<p>It&rsquo;s best practice to define your factories with the minimum set of attributes necessary for a valid object. You don&rsquo;t want to set land-mines for the next developer that comes along and calls <code>create</code>. So the couch_crashes factory generates associated traveller and homebody objects. In doing so, it involves two of our most bloated models. Take a look at their factories:</p>

<p>```ruby</p>

<h1>spec/factories/travellers.rb</h1>

<p>FactoryGirl.define do
  factory :traveller do</p>

<pre><code>first_name "Yngwie"
last_name  "Malmsteen"
association :hometown, factory: :city
luggage
bicycle

after(:build) do |traveller|
  pump = FactoryGirl.build(:bicycle_pump)
  traveller.bike_pump = pump
  traveller.inflate_tires
  traveller.pack_luggage
  traveller.buy_stamps
  # etc.
</code></pre>

<p>  end
end</p>

<h1>spec/factories/homebodies.rb</h1>

<p>FactoryGirl.define do
  factory :homebody do</p>

<pre><code>first_name "Joe"
last_name  "Stumps"
spouse
credit_score 400
house
couch
car
dog
# etc.
</code></pre>

<p>  end
end
```</p>

<p>We&rsquo;re also unintentionally hitting the database, as FactoryGirl saves both traveller and homebody in order to build the association. You can avoid this by specifying a build-strategy for the association:</p>

<p><code>ruby
factory :couch_crash do
  association :traveller, strategy: :build
  association :homebody,  strategy: :build
  ...
</code></p>

<p>You&rsquo;d also have to change the syntax in the associated factories:
```ruby
factory :traveller do
  &hellip;
  association :luggage, strategy: :build
  association :bicycle, strategy: :build
  &hellip;
end</p>

<p>factory :homebody do
  &hellip;
  association :house, strategy: :build
  association :couch, strategy: :build
  association :car,   strategy: :build
  association :dog,   strategy: :build
  &hellip;
end
```</p>

<p>It would be nice to avoid involving these large models any more than necessary, so let&rsquo;s rewrite the spec with a different technique. Instead of using factories to generate complex test objects, we&rsquo;ll use test doubles to stub out the context.</p>

<h3>Test-doubles</h3>

<p>Rspec&rsquo;s <code>double</code> method returns a test-double &mdash; a dummy object that stands in for a more complex object from your production code. The double can be told how to respond to various method calls:
```ruby
red_thing = double(&ldquo;thing&rdquo;)</p>

<h1>The argument (ie. &ldquo;thing&rdquo;) is optional.</h1>

<h1>It provides a name that test output can make use of.</h1>

<p>red_thing.stub(:color).and_return(&ldquo;red&rdquo;)</p>

<h1>equivalent form:</h1>

<p>red_thing.stub(:color) { &ldquo;red&rdquo; }</p>

<h1>Or, more concisely:</h1>

<p>red_house = double(&ldquo;thing&rdquo;, color: &ldquo;red&rdquo;)
```</p>

<p>The double only knows what it&rsquo;s been told explicitly, and will raise an error upon receiving any unexpected method call. If you&rsquo;re using Rspec 3, you can also use &ldquo;<a href="https://www.relishapp.com/rspec/rspec-mocks/v/3-1/docs/verifying-doubles">verifying doubles</a>&rdquo;, which know what class of object they&rsquo;re standing in for and will ensure that any methods being stubbed are actually present in the code.</p>

<h3>Rewrite</h3>

<p>While our spec should still read from the ground up, beginning with the context and arriving at an expectation, it can be helpful when <em>writing</em> to start with the expectation and work backwards. This is especially true when the context is complex. It also helps clarify what needs to be stubbed out, so let&rsquo;s give it a shot.
<code>ruby
expect(visit.status).to eq(:approaching)
</code>
What is <code>visit</code>? Just a test double with the right attributes:
<code>ruby
visit = double("visit", arrival_date: 1.week.from_now, postcards: [postcard_100])
</code>
What about <code>postcard_100</code>? Just another test double.
<code>ruby
postcard_100 = double("postcard", distance: 100)
</code>
Putting it all together, we have:</p>

<p>```ruby
context &lsquo;within 1 week of arrival date&rsquo; do
  context &lsquo;with a postcard from 100 miles away&rsquo; do</p>

<pre><code>it 'is "approaching"' do
  postcard_100 = double("postcard", distance: 100)
  visit = double("visit", arrival_date: 1.week.from_now, postcards: [postcard_100])

  expect(visit.status).to eq(:approaching)
end
</code></pre>

<p>  end
end
```</p>

<p>I initially wanted faster specs to enable a better TDD flow. A nice side benefit of writing these stubbed tests is that it illuminates the dependencies and coupling in the production code you&rsquo;re working with and encourages better composition overall. FactoryGirl is still a wonderful tool, but it shouldn&rsquo;t be the only one in your belt.</p>
]]></content>
  </entry>
  
</feed>
