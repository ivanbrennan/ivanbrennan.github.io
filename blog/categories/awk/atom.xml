<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: awk | codemachine]]></title>
  <link href="http://ivanbrennan.github.io/blog/categories/awk/atom.xml" rel="self"/>
  <link href="http://ivanbrennan.github.io/"/>
  <updated>2017-08-06T07:57:32-04:00</updated>
  <id>http://ivanbrennan.github.io/</id>
  <author>
    <name><![CDATA[Ivan Brennan]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[History: filtered vs unfiltered]]></title>
    <link href="http://ivanbrennan.github.io/blog/2017/08/05/command-history-filter/"/>
    <updated>2017-08-05T08:49:00-04:00</updated>
    <id>http://ivanbrennan.github.io/blog/2017/08/05/command-history-filter</id>
    <content type="html"><![CDATA[<p>I get a lot of use out of shell history. At its simplest, tapping <code>↑</code> cycles through previous commands. Incremental search (<code>C-r</code>) will retrieve matching history entries, updating as you type. There are more ways you can access history, but these two in particular have become ingrained in my workflow.</p>

<p>I&rsquo;m running Bash (for now), and have it configured to save a good deal of history:
<code>sh
export HISTSIZE=10000
shopt -s histappend
</code>
When you start a shell, Bash reads <code>~/.bash_history</code> (or <code>$HISTFILE</code> if that&rsquo;s been set), initializing the in-memory history your session will interact with. When exiting the shell, new history is written to disk, making it available to future sessions. With <code>histappend</code> set, the history file is appended to rather than overwritten.</p>

<p>I&rsquo;ve also configured it to save multiline commands with embedded newlines, separated by timestamps. This makes it easy to recall and modify more complex commands, like loops and functions.
<code>sh
export HISTTIMEFORMAT='%F %T '
shopt -s cmdhist lithist
</code></p>

<p>Bash has a <code>HISTIGNORE</code> variable that can hold patterns you want to exclude from history. The patterns are colon-separated and treated as shell globs that must match the entire line. Multiline entries are decided based on the first line.</p>

<p>If, for example, you wanted to ignore the <code>jobs</code> builtin and any <code>ls</code> commands, you could set:
<code>sh
HISTIGNORE='jobs:ls[ ]*'
</code>
I tried this out but quickly realized I prefer an unfiltered recent history. If I run,</p>

<pre><code>ls /path/to/some/directory
</code></pre>

<p>I want to be able to repeat <code>ls</code> on a subdirectory by tapping <code>↑</code> and appending to the path.</p>

<p>More distant history, on the other hand, could benefit from filtering. I don&rsquo;t see much value in persisting <code>ls</code> or <code>man</code> commands from one session to the next. I&rsquo;m not likely to search for them, and when I&rsquo;m reaching back into a previous session&rsquo;s history it&rsquo;s nearly always via search &mdash; either <em>reverse-search-history</em> (<code>C-r</code>) or the less well-known <em>history-search-backward</em>, which retrieves the previous command matching what you&rsquo;ve already typed, and which I&rsquo;ve bound to <code>M-p</code>.</p>

<p>The only things I&rsquo;m using <code>HISTIGNORE</code> for are commands like <code>jobs</code> and <code>fg</code>, which I tend to just retype.</p>

<h3>Filtering persisted history</h3>

<p>To keep commands like <code>ls</code> from polluting the history of future shell sessions, I&rsquo;ve written a script to filter my <code>~/.bash_history</code> when exiting the shell. The script is triggered by an <code>EXIT</code> trap in my <code>~/.bashrc</code>:
<code>sh
if [[ $- == *i* ]]; then
  trap '$HOME/.bash_history_filter &gt;/dev/null 2&gt;&amp;1 &amp;' EXIT
fi
</code>
The cryptic <code>$-</code> variable holds flags indicating which shell options are in effect, and I&rsquo;m using it to restrict the trap to interactive shells (indicated by the <code>i</code> flag). The script it runs is as follows:
```sh</p>

<h1>!/bin/sh</h1>

<p>tmpfile=$(mktemp)
trap &lsquo;rm -f &ldquo;$tmpfile&rdquo;&rsquo; EXIT</p>

<p>awk_script=&ldquo;$HOME/.bash_history_filter.awk&rdquo;
persisted_history=&ldquo;${HISTFILE:&ndash;$HOME/.bash_history}&rdquo;</p>

<p>if [[ -r &ldquo;$awk_script&rdquo; &amp;&amp; -r &ldquo;$persisted_history&rdquo; ]]; then
  awk -f &ldquo;$awk_script&rdquo; &ldquo;$persisted_history&rdquo; > &ldquo;$tmpfile&rdquo;</p>

<p>  mv &ldquo;$tmpfile&rdquo; &ldquo;$persisted_history&rdquo;
fi
<code>``
The actual filtering logic lives in an Awk script. The shell history is run through that filter and output to a temporary file, which subsequently replaces the original history file. An exit trap will remove the temporary file if something goes wrong and the script exits before executing the</code>mv`.</p>

<p>Awk processes input one line at a time, splitting the line into individual fields (space-delimited by default). The fields are referenceable as <code>$1</code>, <code>$2</code>, etc. and the entire line is available in <code>$0</code>. Each line is run through the set of Awk commands you define. A common idiom, in pseudocode is:</p>

<pre><code>/pattern/ {
  # commands to run on any line matching pattern 
}

$1 ~ /word/ {
  # commands to run on any line whose first field matches word 
}
</code></pre>

<p>You can call <code>next</code> to skip any subsequent commands and jump to the next line of input. You can also set and manipulate variables to track state, accumulate text, etc. and <code>print</code> to write output. My filter is:
```awk
/^#[[:digit:]]{10}$/ {
  timestamp = $0
  histentry = &ldquo;&rdquo;
  next
}</p>

<p>($1 ~ /^(ls?|man|cat)$/) || /^[[:alpha:]]$/ {
  if (! timestamp) {</p>

<pre><code>print
</code></pre>

<p>  } else {</p>

<pre><code>histentry = $0
</code></pre>

<p>  }
  next
}</p>

<p>timestamp {
  print timestamp
  timestamp = &ldquo;&rdquo;
}</p>

<p>histentry {
  print histentry
  histentry = &ldquo;&rdquo;
}</p>

<p>{ print }
```</p>

<p>It&rsquo;s essentially a state-machine.</p>

<p><img class="state-machine" src="/images/history-filter/state-machine.png" title="&lsquo;state-machine&rsquo; &lsquo;state-machine&rsquo;" ></p>

<p>Getting the Awk script just right took some work, and I found it helpful to have some <a href="https://github.com/ivanbrennan/dotfiles/blob/master/shell/filter_test">automated tests</a> at my back as I fiddled with it.</p>

<p>When processing multiline entries, I decided that if a command is complex enough to warrant mutliple lines, it&rsquo;s worth remembering, even if its first line matches an &ldquo;uninteresting&rdquo; pattern. The &ldquo;uninteresting&rdquo; predicate ended up as:</p>

<pre><code>($1 ~ /^(ls?|man|cat)$/) || /^[[:alpha:]]$/
</code></pre>

<p>This matches some commands that are uninteresting with or without arguments, any line that consists of a single letter. I have some functions/aliases I use &mdash; <code>v</code> for (neo)vim, <code>e</code> for emacs, <code>t</code> for tmux &mdash; which aren&rsquo;t very interesting by themselves, but could have interesting arguments. I frequently use <code>C-r</code>, for example, to recall/reuse a previous <code>tmux new-session</code> command:</p>

<pre><code>t new-session -s ruby-project -c /path/to/ruby-project
</code></pre>

<p>I tried out Sed as an alternative to Awk for this use, but decided against it. Sed has an extremely terse syntax and fought me most of the way. I finally found a couple ways to make it work, but they&rsquo;re pretty gnarly. If you install GNU Sed, you can tell Sed to treat lines as separated by NULL bytes. The entire file will be slurped into a single &ldquo;line&rdquo; on which you can apply substitution:</p>

<pre><code>gsed --null-data \
     --regexp-extended \
     's/(#[0-9]{10}\n((cat|ls?|man)([^[:alnum:]][^\n]*)?|[[:alpha:]])\n)+(#[0-9]{10}\n|$)/\5/g' \
     "$infile" &gt;"$outfile"
</code></pre>

<p>Sed implementations that don&rsquo;t have the NULL byte trick up their sleeve (e.g. BSD Sed), will instead have to juggle data back and forth between the &ldquo;hold-space&rdquo; and &ldquo;pattern-space&rdquo;. I scripted this out of morbid curiosity, but I wouldn&rsquo;t wish it on anyone:</p>

<pre><code>sed -E -f horrendous.sed "$infile" &gt;"$outfile"
</code></pre>

<p>with the following <code>horrendous.sed</code> script:</p>

<pre><code>$ {
  1 h
  1!H
  x
  /^#[[:digit:]]{10}\n((ls?|cat|man)([^[:alnum:]][[:print:]]*)?|[[:alpha:]])$/ d
  p
}

/^#[[:digit:]]{10}$/ !{
  1 h
  1!H
  d
}

x
/^$/ d
/^#[[:digit:]]{10}$/ d
/^#[[:digit:]]{10}\n((ls?|cat|man)([^[:alnum:]][[:print:]]*)?|[[:alpha:]])$/ d
</code></pre>

<p>Benchmarking the Awk, GNU Sed, and Sed solutions on a 50,000 line file:</p>

<pre><code>awk  0.070s
gsed 0.060s
sed  0.080s
</code></pre>

<p>Awk is the best choice, I think. GNU Sed can shave 10 milliseconds off the run time, but the extra dependency and the 80+ character regex aren&rsquo;t worth it.</p>
]]></content>
  </entry>
  
</feed>
