
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Rigging Vim's Netrw - codemachine</title>
  <meta name="author" content="Ivan Brennan">

  
  <meta name="description" content="If you&rsquo;re a Vim user, you&rsquo;re probably familiar with the NERDTree, a plugin that provides a sidebar for navigating the filesystem, much &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://ivanbrennan.github.io/blog/2014/01/16/rigging-vims-netrw">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="codemachine" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">codemachine</a></h1>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:ivanbrennan.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">Rigging Vim's Netrw</h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-01-16T01:00:00-05:00" pubdate data-updated="true">Jan 16<span>th</span>, 2014</time>
        
      </p>
    
  </header>


<div class="entry-content"><p>If you&rsquo;re a Vim user, you&rsquo;re probably familiar with the <a href="http://www.vim.org/scripts/script.php?script_id=1075">NERDTree</a>, a plugin that provides a sidebar for navigating the filesystem, much like you get with a more graphical editor such as Sublime Text. It&rsquo;s a nice feature, but you don&rsquo;t necessarily need to install another plugin to get it. Most distributions of Vim come with <a href="http://www.vim.org/scripts/script.php?script_id=1075">Netrw</a> already built in. Built by <a href="http://www.drchip.org/astronaut/index.html">Charles CampBell</a>, Netrw is a plugin for browsing, reading, and writing files both locally and across networks.</p>

<p>Netrw is not NERDTree. It does much more, but the flip side is that NERDTree focuses on doing one thing well. That being said, at some point I got interested in reproducing what I liked about NERDTree using the built-in capabilities of Netrw. It took a bit of configuration and some dirty language (vimscript) but if you&rsquo;re not averse to any of that, read on.</p>

<p><img class="screenshot" src="/images/vextoggle/4.png" title="vim" alt="vim screenshot"></p>

<p>My first goal was to toggle a sidebar navigator open/closed with a keystroke or two. The <code>:Vexplore</code> command opens a Netrw browser in a vertical split. If you pass the command a directory, it will open into that location, otherwise it opens in the current file&rsquo;s parent directory. There&rsquo;s a distinction between the current file&rsquo;s parent directory and the &ldquo;current working directory&rdquo; that Vim keeps track of. Say you start Vim from within ~/Development. You can <code>:edit</code> files anywhere you like (~/Development/resources, ~, /usr/local, etc.), and until you explicitly tell Vim to <code>:cd</code> to a new location, the current working directory will remain where it started, at ~/Development. You can use this as a home-base to work from in the current Vim session. With this in mind, I composed a small set of functions to toggle the sidebar in either the current file&rsquo;s directory (to access neighboring files), or the &ldquo;current working directory&rdquo; (which I tend to leave at the project root), and mapped them to a couple keystrokes I find convenient.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='vim'><span class='line'><span class="k">fun</span><span class="p">!</span> VexToggle<span class="p">(</span><span class="nb">dir</span><span class="p">)</span>
</span><span class='line'>  <span class="k">if</span> exists<span class="p">(</span><span class="s2">&quot;t:vex_buf_nr&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="k">call</span> VexClose<span class="p">()</span>
</span><span class='line'>  <span class="k">else</span>
</span><span class='line'>    <span class="k">call</span> VexOpen<span class="p">(</span><span class="k">a</span>:<span class="nb">dir</span><span class="p">)</span>
</span><span class='line'>  <span class="k">endif</span>
</span><span class='line'><span class="k">endf</span>
</span></code></pre></td></tr></table></div></figure>


<p>I&rsquo;m using <code>t:vex_buf_nr</code> to track whether the sidebar is currently open. The <code>t:</code> is scoping the variable to the current tab. That&rsquo;s so each tab can have its own sidebar. If you&rsquo;re not familiar with Vim&rsquo;s tabs, don&rsquo;t worry about it. It&rsquo;s a minor detail here. In the else clause, we pass <code>a:dir</code> (the <code>dir</code> argument that was passed into <code>VexToggle()</code>) to <code>VexOpen()</code>.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='vim'><span class='line'><span class="k">fun</span><span class="p">!</span> VexOpen<span class="p">(</span><span class="nb">dir</span><span class="p">)</span>
</span><span class='line'>  <span class="k">let</span> <span class="k">g</span>:netrw_browse_split<span class="p">=</span><span class="m">4</span>    <span class="c">&quot; open files in previous window</span>
</span><span class='line'>  <span class="k">let</span> vex_width <span class="p">=</span> <span class="m">25</span>
</span><span class='line'>
</span><span class='line'>  execute <span class="s2">&quot;Vexplore &quot;</span> . <span class="k">a</span>:<span class="nb">dir</span>
</span><span class='line'>  <span class="k">let</span> <span class="k">t</span>:vex_buf_nr <span class="p">=</span> bufnr<span class="p">(</span><span class="s2">&quot;%&quot;</span><span class="p">)</span>
</span><span class='line'>  <span class="k">wincmd</span> H
</span><span class='line'>
</span><span class='line'>  <span class="k">call</span> VexSize<span class="p">(</span>vex_width<span class="p">)</span>
</span><span class='line'><span class="k">endf</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>VexOpen()</code> starts by setting some options. &ldquo;Open files in previous window&rdquo; ensures that when we select a file to open, it opens in the window (split) we were in before entering the browser. We&rsquo;re also setting the desired window width for later use.</p>

<p>Next, we use vimscript&rsquo;s string concatenation operator (<code>.</code>) to compose the <code>Vexplore</code> call. It&rsquo;s a little ugly, but sometimes vimscript paints you into a corner like that. Now that we have an explorer open, let&rsquo;s remember it (the next line). The <code>"%"</code> expands to the current file name, and we store the associated buffer number for later reference.</p>

<p>If you have several splits open, calling <code>:Vexplore</code> will open a Netrw explorer in a vertical split next to <em>the current split</em>, so there&rsquo;s no guarantee it will sit on the far left of the screen or even occupy the full height of Vim. Calling <code>wincmd H</code> fixes that. Finally, calling <code>VexSize()</code> will set the sidebar&rsquo;s width.</p>

<p>I made a couple mappings to call <code>VexToggle()</code>. The first passes it Vim&rsquo;s &ldquo;current working directory&rdquo; as an argument, while the second passes an empty string. That way, I can use the first mapping to toggle an explorer sidebar from the project root and the second to toggle an explorer from whichever directory houses the file I&rsquo;m currently editing.</p>

<pre><code>noremap &lt;Leader&gt;&lt;Tab&gt; :call VexToggle(getcwd())&lt;CR&gt;
noremap &lt;Leader&gt;` :call VexToggle("")&lt;CR&gt;
</code></pre>

<p><img class="screenshot" src="/images/vextoggle/8.png" title="vim" alt="vim screenshot"></p>

<p>When the sidebar is open, either mapping can be used to close it. <code>VexClose()</code> starts by noting which window it was called from, so it can return the cursor to that window after the sidebar has closed. The exception is when the cursor was <em>in</em> the sidebar when <code>VexClose()</code> was called, in which case the cursor will land in the previous window (whichever window holds the alternate file <code>"#"</code>). The middle section switches to the sidebar, closes it, and removes the internal variable that was tracking its presence. Finally, we switch to the appropriate destination window and call <code>NormalizeWidths()</code> to normalize the widths of all open windows. Note that we have to subtract 1 from the original window number that was stored, since closing the sidebar window decremented all the remaining window numbers.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='vim'><span class='line'><span class="k">fun</span><span class="p">!</span> VexClose<span class="p">()</span>
</span><span class='line'>  <span class="k">let</span> cur_win_nr <span class="p">=</span> winnr<span class="p">()</span>
</span><span class='line'>  <span class="k">let</span> target_nr <span class="p">=</span> <span class="p">(</span> cur_win_nr <span class="p">==</span> <span class="m">1</span> ? winnr<span class="p">(</span><span class="s2">&quot;#&quot;</span><span class="p">)</span> : cur_win_nr <span class="p">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="m">1</span>wincmd <span class="k">w</span>
</span><span class='line'>  <span class="k">close</span>
</span><span class='line'>  unlet <span class="k">t</span>:vex_buf_nr
</span><span class='line'>
</span><span class='line'>  execute <span class="p">(</span>target_nr <span class="p">-</span> <span class="m">1</span><span class="p">)</span> . <span class="s2">&quot;wincmd w&quot;</span>
</span><span class='line'>  <span class="k">call</span> NormalizeWidths<span class="p">()</span>
</span><span class='line'><span class="k">endf</span>
</span></code></pre></td></tr></table></div></figure>


<p><img class="screenshot" src="/images/vextoggle/10.png" title="vim" alt="vim screenshot"></p>

<p>All that&rsquo;s left are the final touches to window sizing, which occur in <code>VexSize()</code> and <code>NormalizeWidths()</code>. The first function sets and locks the sidebar width, then calls the second to normalize the widths off all other windows. <code>NormalizeWidths()</code> is a little hacky, but as far as I can tell it&rsquo;s the only native vimscript way to normalize window widths without affecting their heights. <code>'eadirection'</code> controls which dimensions are affected when <code>'equal always'</code> is set. We set it to <code>hor</code> (horizontal), toggle <code>'equal always'</code> off and back on (it&rsquo;s on by default), triggering the width normalization, and finally restore <code>'eadirection'</code> to it&rsquo;s original value.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='vim'><span class='line'><span class="k">fun</span><span class="p">!</span> VexSize<span class="p">(</span>vex_width<span class="p">)</span>
</span><span class='line'>  execute <span class="s2">&quot;vertical resize&quot;</span> . <span class="k">a</span>:vex_width
</span><span class='line'>  <span class="k">set</span> <span class="nb">winfixwidth</span>
</span><span class='line'>  <span class="k">call</span> NormalizeWidths<span class="p">()</span>
</span><span class='line'><span class="k">endf</span>
</span><span class='line'>
</span><span class='line'><span class="k">fun</span><span class="p">!</span> NormalizeWidths<span class="p">()</span>
</span><span class='line'>  <span class="k">let</span> eadir_pref <span class="p">=</span> &amp;<span class="nb">eadirection</span>
</span><span class='line'>  <span class="k">set</span> <span class="nb">eadirection</span><span class="p">=</span>hor
</span><span class='line'>  <span class="k">set</span> <span class="nb">equalalways</span><span class="p">!</span> <span class="nb">equalalways</span><span class="p">!</span>
</span><span class='line'>  <span class="k">let</span> &amp;<span class="nb">eadirection</span> <span class="p">=</span> eadir_pref
</span><span class='line'><span class="k">endf</span>
</span></code></pre></td></tr></table></div></figure>


<p>Netrw lets you open a selected file in a vertical split with the <code>v</code> key, and I wanted to normalize window widths when such a split was added so things would remain evenly sized. The following autocommand makes it so.</p>

<pre><code>augroup NetrwGroup
  autocmd! BufEnter * call NormalizeWidths()
augroup END
</code></pre>

<p><img class="screenshot" src="/images/vextoggle/12.png" title="vim" alt="vim screenshot"></p>

<p><strong><em>Closing Notes</em></strong></p>

<p>I ran into a couple minor bugs in Netrw during all of this, and turned to the <a href="https://groups.google.com/forum/#!topic/vim_use/XNOcLYsgk8Y">vim_use</a> mailing list for help. Netrw&rsquo;s author (Dr. Chip) was quick to respond with a fix and point me toward the <a href="http://www.drchip.org/astronaut/vim/index.html#NETRW">newest version</a>. Big thanks Dr. Chip!</p>

<p>I find myself mostly using Netrw&rsquo;s &ldquo;thin&rdquo; liststyle rather than the &ldquo;tree&rdquo; style I originally liked, but both work equally well in the sidebar. Finally, my <a href="https://github.com/ivanbrennan/vim/blob/master/vimrc">vimrc</a> is available for reference, though the relevant Netrw settings I&rsquo;m using are pasted below:</p>

<pre><code>let g:netrw_liststyle=0         " thin (change to 3 for tree)
let g:netrw_banner=0            " no banner
let g:netrw_altv=1              " open files on right
let g:netrw_preview=1           " open previews vertically
</code></pre>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">Ivan Brennan</span></span>

      








  


<time datetime="2014-01-16T01:00:00-05:00" pubdate data-updated="true">Jan 16<span>th</span>, 2014</time>
      

<span class="categories">
  
    <a class='category' href='/blog/categories/vim/'>vim</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  <a href="//twitter.com/share" class="twitter-share-button" data-url="http://ivanbrennan.github.io/blog/2014/01/16/rigging-vims-netrw/" data-via="" data-counturl="http://ivanbrennan.github.io/blog/2014/01/16/rigging-vims-netrw/" >Tweet</a>
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2014/01/14/polymorphic-mythology/" title="Previous Post: Polymorphic Mythology">&laquo; Polymorphic Mythology</a>
      
      
        <a class="basic-alignment right" href="/blog/2014/10/26/vim-key-mappings/" title="Next Post: vim key-mappings">vim key-mappings &raquo;</a>
      
    </p>
  </footer>
</article>

  <section>
    <h1>Comments</h1>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
  </section>

</div>

<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2018/01/06/follow-the-types/">Type Tetris</a>
      </li>
    
      <li class="post">
        <a href="/blog/2017/08/05/command-history-filter/">History: Filtered vs Unfiltered</a>
      </li>
    
      <li class="post">
        <a href="/blog/2017/06/03/shell-while-loops-and-variables/">Shell: While Loops and Variables</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/12/20/debugging-etags/">Debugging Etags</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/06/06/karabiner/">Karabiner</a>
      </li>
    
  </ul>
</section>

  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2018 - Ivan Brennan -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'codemachine';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://ivanbrennan.github.io/blog/2014/01/16/rigging-vims-netrw/';
        var disqus_url = 'http://ivanbrennan.github.io/blog/2014/01/16/rigging-vims-netrw/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
